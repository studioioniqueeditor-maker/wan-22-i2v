# Continue Rules - wan-22-i2v

## Detected Conventions

# Codebase Analysis: Vivid Flow - Wan 2.1 & Veo 3.1 I2V Client

## Project Overview
Vivid Flow is a professional-grade toolkit and web interface for generating videos from images using state-of-the-art AI models:
- **Wan 2.1** (via RunPod)
- **Google Veo 3.1** (via Vertex AI)

This is a production-ready application with a complete web interface, authentication system, and API.

## Architecture & Structure

### Core Components
1. **Web Application** (`web_app.py`) - Flask-based application with:
   - User authentication (Supabase)
   - Video generation workflows
   - File upload and management
   - History tracking
   - RESTful API endpoints

2. **Model Clients**:
   - `vertex_ai_veo_client.py` - Google Veo 3.1 integration
   - Interface-based architecture for extensibility

3. **Services**:
   - `auth_service.py` - Supabase authentication integration
   - `storage_service.py` - Google Cloud Storage integration
   - `prompt_enhancer.py` - Text prompt enhancement using Groq
   - `veo_prompt_enhancer.py` - Google-specific prompt enhancement

4. **Frontend**:
   - Responsive HTML templates with Bootstrap
   - Glassmorphism-inspired UI
   - Real-time previews and history tracking

### Key Features
- **Dual Model Support**: Seamless switching between Wan 2.1 and Google Veo 3.1
- **Authentication**: Secure user registration/login with Supabase
- **Cloud Storage**: Automated video upload to Google Cloud Storage
- **Prompt Enhancement**: AI-powered prompt optimization
- **Public API**: RESTful API with API key authentication
- **Rate Limiting**: Protection against abuse
- **Comprehensive Logging**: Detailed application monitoring

## Technical Implementation

### Backend Stack
- **Framework**: Flask (Python)
- **Authentication**: Supabase
- **Cloud Services**: Google Cloud Platform (Vertex AI, Cloud Storage)
- **AI Services**: 
  - Groq for prompt enhancement
  - Google Veo 3.1 for video generation
  - RunPod for Wan 2.1
- **Database**: Supabase (PostgreSQL) with Row-Level Security
- **Deployment**: Google Cloud Run with Docker

### Frontend Stack
- **UI Framework**: Bootstrap 5
- **Styling**: Custom CSS with glassmorphism design
- **JavaScript**: Vanilla JS with modern ES6 features
- **Responsive Design**: Mobile-friendly layout

### Security & Reliability
- API key authentication
- Rate limiting
- Secure session management
- Environment-based configuration
- Comprehensive error handling
- Detailed logging system

## Database Schema
The application uses Supabase with two main tables:
1. **Profiles**: User profile information linked to auth.users
2. **History**: Video generation history with RLS policies

## API Endpoints
The system provides both a web interface and a public API:
- `/api/v1/generate` - Video generation
- `/api/v1/status/{job_id}` - Job status checking
- `/api/v1/history` - Generation history
- `/api/v1/usage` - Usage metrics

## Deployment
The application is designed for Google Cloud Run deployment:
- Containerized with Docker
- Automated deployment script
- Environment-based configuration
- Cloud-native architecture

## Testing
The codebase includes a comprehensive test suite:
- Unit tests for core components
- Mock-based testing for external services
- Test coverage reporting

This is a well-structured, production-ready application with clear separation of concerns, robust error handling, and professional-grade features. The code follows modern software engineering practices with proper documentation, testing, and deployment strategies.

## Project-Specific Rules
- Follow existing patterns in vertex_ai_veo_client.py and web_app.py
- Use python+flask+vertex ai+gcp for the project
- Maintain consistency with production engineering style

# Continue Rules - Multi-Agent Workflow

## Core Principles
- Follow the conductor workflow: Plan → Implement → Test → Debug
- Use the appropriate model for each phase
- Write production-ready code that runs immediately
- Include comprehensive error handling
- Add clear documentation and comments

## Code Quality Standards
- Use functional and declarative patterns (avoid classes unless needed)
- Handle errors at function start with early returns
- Add type hints/annotations (Python, TypeScript)
- Include docstrings for all functions
- Optimize for readability first, performance second
- Follow language-specific conventions

## File Organization
- Keep files under 500 lines
- One main responsibility per file
- Clear, descriptive file names (avoid generic names like utils.js)
- Group related functionality

## Testing Requirements
- Write tests for all new features
- Use AAA pattern (Arrange, Act, Assert)
- Test both success and error paths
- Mock external dependencies
- Aim for high coverage on critical paths

## Git Commits
- Use conventional commits: type(scope): message
- Types: feat, fix, docs, style, refactor, test, chore
- Clear, descriptive messages
- Commit after each completed phase

## Dependencies
- Specify exact versions in dependency files
- Document why each dependency is needed
- Minimize dependencies (prefer standard library)

## Communication
- Use ### for section headings
- **Bold** for critical information
- `Code formatting` for technical terms
- Clear bullet points with action items

## Workflow
When given a task:
1. Use /plan to create architecture
2. Use /implement to build features
3. Use /test to write tests
4. Use /debug if issues arise